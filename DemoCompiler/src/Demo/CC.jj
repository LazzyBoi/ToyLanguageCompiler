/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. CC.jj */
/*@egen*/
options {
   STATIC = false;   // this allows only one parser object to be present default: true
   BUILD_PARSER = true;  // default: true
   BUILD_TOKEN_MANAGER = true; // default: true
   SANITY_CHECK = true; // performs syntactic and semantic checks such as detection of left recursion, detection of ambiguity and bad usage of empty expansions
   IGNORE_CASE = false;  // generated token manager ignores case in the token specifications and the input files default: false
   LOOKAHEAD = 1;    // The number of tokens to look ahead before making a decision at a choice point during parsing default: 1
//   CHOICE_AMBIGUITY_CHECK = 2;  the number of tokens considered in checking choices of the form "A | B | ..." for ambiguity
     JAVA_UNICODE_ESCAPE = true; // the generated parser uses an input stream object that processes Java Unicode escapes
//   UNICODE_INPUT = false;      // the generated parser uses an input stream object that reads Unicode files
  FORCE_LA_CHECK=true;
  JAVA_UNICODE_ESCAPE = true;
               
                 
 }
 PARSER_BEGIN(CMinusParser)
 package Demo;

    public class CMinusParser/*@bgen(jjtree)*/implements CMinusParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTCMinusParserState jjtree = new JJTCMinusParserState();

/*@egen*/
        ParseResult result = new ParseResult();
        public ParseResult Parse(){

               try {
               Program().dump("");
               }
               catch (ParseException e){
               result.addException(e);
               }
               return result;
        }

    }

 PARSER_END(CMinusParser)











/* white space is to be ignored*/
SKIP :
{
  " "    // blanks
| "\t"   // tab
| "\n"   // new line (line feed) character
| "\r"   // carriage return character (these and new line characters are skipped)
| "\f"
| < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") > // skip single-line comments
}


/* COMMENTS */
SKIP :
{
  "/*" : WithinComment
}

<WithinComment> SKIP :
{
  "*/" : DEFAULT
}



/* COMMENTS_2 */
SKIP:
{
	"//":WithinComment2
}


<WithinComment2> SKIP:
{
	"\n":DEFAULT
}

<WithinComment> MORE :
{
  <~[]>
}

/* exponent */
TOKEN :
{
<#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >  	
}

/* fraction */
TOKEN :
{
<FRACTION: <DOT> (["0"-"9"])+ >
}


/* realnumber */
TOKEN :
{
<REALNUMBER:<intnumber><EXPONENT>|<intnumber><FRACTION>(<EXPONENT>)?>
}

/* NUM */
TOKEN:
{
	<NUM:<REALNUMBER>|<intnumber>|<digit>>
}





/* keywords of C- */
TOKEN :
{
 < ELSE: "else" >
| < IF: "if" >
| < INT: "int" >
| < RETURN: "return" >
| < VOID: "void" >
| < WHILE: "while" >
| < REAL: "real">
| < THEN: "then">
}

/* identifier */
TOKEN :
{
  < ID: <letter> (<letter>|<digit>)* >
|
  < #letter:
      [
         "A"-"Z",
         "a"-"z"
      ]
  >
}

/* intNumber */
TOKEN :
{
  < intnumber: <digit> (<digit>)* >
}


/* digit */
TOKEN :
{
< #digit:
      [
         "0"-"9"
      ]
>
}


/* SEPARATORS */
TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

/* OPERATORS */
TOKEN :
{
  < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < ASSIGN: "=" >
| < LT: "<" >
| < RT: ">" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >

}





SimpleNode Program():
{/*@bgen(jjtree) Program */
 ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/System.out.println("Pragram start");}
{/*@bgen(jjtree) Program */
        try {
/*@egen*/
	compoundstmt()<EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return jjtn000;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



void stmt():
{/*@bgen(jjtree) stmt */
  ASTstmt jjtn000 = new ASTstmt(JJTSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) stmt */
        try {
/*@egen*/	
	decl()|ifstmt()|whilestmt()|assgstmt()|compoundstmt()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void compoundstmt():
{/*@bgen(jjtree) compoundstmt */
        ASTcompoundstmt jjtn000 = new ASTcompoundstmt(JJTCOMPOUNDSTMT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	System.out.println("compoundstmt");
}
{/*@bgen(jjtree) compoundstmt */
        try {
/*@egen*/
	

	lb() stmts() rb()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void lb():
{/*@bgen(jjtree) lb */
  ASTlb jjtn000 = new ASTlb(JJTLB);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) lb */
  try {
/*@egen*/
  "{"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void rb():
{/*@bgen(jjtree) rb */
  ASTrb jjtn000 = new ASTrb(JJTRB);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) rb */
  try {
/*@egen*/
  "}"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



//the way solving the exception
JAVACODE
void errorSkipTo(int kind){/*@bgen(jjtree) errorSkipTo */
     ASTerrorSkipTo jjtn000 = new ASTerrorSkipTo(JJTERRORSKIPTO);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
     try {
/*@egen*/
	ParseException e = generateParseException();
	result.addException(e);
	Token t;
	do{
		t = getNextToken();
	}while(t.kind!=kind&&t.kind!=EOF);/*@bgen(jjtree)*/
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
	//Because the next token is wrong, so we have to skip it
	//do-loop skip the wrong token
}

void stmts():
{/*@bgen(jjtree) stmts */
  ASTstmts jjtn000 = new ASTstmts(JJTSTMTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) stmts */
        try {
/*@egen*/
	stmt() stmts()|epsilon()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ifstmt():
{/*@bgen(jjtree) ifstmt */
  ASTifstmt jjtn000 = new ASTifstmt(JJTIFSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ifstmt */
        try {
/*@egen*/
	iff() leftb() boolexpr() rightb() thenn() stmt() els() stmt()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void thenn():
{/*@bgen(jjtree) thenn */
  ASTthenn jjtn000 = new ASTthenn(JJTTHENN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) thenn */
  try {
/*@egen*/
  "then"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void els():
{/*@bgen(jjtree) els */
  ASTels jjtn000 = new ASTels(JJTELS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) els */
  try {
/*@egen*/
  "else"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void iff():
{/*@bgen(jjtree) iff */
  ASTiff jjtn000 = new ASTiff(JJTIFF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) iff */
  try {
/*@egen*/
  "if"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void whilestmt():
{/*@bgen(jjtree) whilestmt */
  ASTwhilestmt jjtn000 = new ASTwhilestmt(JJTWHILESTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) whilestmt */
        try {
/*@egen*/
	loop() leftb() boolexpr() rightb() stmt()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void loop():
{/*@bgen(jjtree) loop */
  ASTloop jjtn000 = new ASTloop(JJTLOOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) loop */
  try {
/*@egen*/
  "while"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void leftb():
{/*@bgen(jjtree) leftb */
  ASTleftb jjtn000 = new ASTleftb(JJTLEFTB);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) leftb */
  try {
/*@egen*/
  "("/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void rightb():
{/*@bgen(jjtree) rightb */
  ASTrightb jjtn000 = new ASTrightb(JJTRIGHTB);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) rightb */
  try {
/*@egen*/
  ")"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void assgstmt():
{/*@bgen(jjtree) assgstmt */
  ASTassgstmt jjtn000 = new ASTassgstmt(JJTASSGSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) assgstmt */
        try {
/*@egen*/
	identity() assi() arithexpr() semicol()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void assi():
{/*@bgen(jjtree) assi */
  ASTassi jjtn000 = new ASTassi(JJTASSI);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) assi */
  try {
/*@egen*/
  "="/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void decl():
{/*@bgen(jjtree) decl */
  ASTdecl jjtn000 = new ASTdecl(JJTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) decl */
        try {
/*@egen*/
	type() list() semicol()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void semicol():
{/*@bgen(jjtree) semicol */
  ASTsemicol jjtn000 = new ASTsemicol(JJTSEMICOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) semicol */
  try {
/*@egen*/
  ";"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void type():
{/*@bgen(jjtree) type */
  ASTtype jjtn000 = new ASTtype(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) type */
        try {
/*@egen*/
	integer() | realnumber()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void integer():
{/*@bgen(jjtree) integer */
  ASTinteger jjtn000 = new ASTinteger(JJTINTEGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) integer */
  try {
/*@egen*/
  "int"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void realnumber():
{/*@bgen(jjtree) realnumber */
  ASTrealnumber jjtn000 = new ASTrealnumber(JJTREALNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) realnumber */
  try {
/*@egen*/
  "real"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void list():
{/*@bgen(jjtree) list */
  ASTlist jjtn000 = new ASTlist(JJTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) list */
        try {
/*@egen*/
	identity() list1()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void identity():
{/*@bgen(jjtree) identity */
  ASTidentity jjtn000 = new ASTidentity(JJTIDENTITY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) identity */
  try {
/*@egen*/
  <ID>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void list1():
{/*@bgen(jjtree) list1 */
  ASTlist1 jjtn000 = new ASTlist1(JJTLIST1);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) list1 */
        try {
/*@egen*/
	comma() list()|epsilon()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void comma():
{/*@bgen(jjtree) comma */
  ASTcomma jjtn000 = new ASTcomma(JJTCOMMA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) comma */
  try {
/*@egen*/
  ","/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



void boolexpr():
{/*@bgen(jjtree) boolexpr */
  ASTboolexpr jjtn000 = new ASTboolexpr(JJTBOOLEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) boolexpr */
        try {
/*@egen*/
	arithexpr() boolop() arithexpr()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void boolop():
{/*@bgen(jjtree) boolop */
  ASTboolop jjtn000 = new ASTboolop(JJTBOOLOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) boolop */
        try {
/*@egen*/
	lessthan()|greaterthan()|lessequal()|greaterequal()|equal()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void lessthan():
{/*@bgen(jjtree) lessthan */
  ASTlessthan jjtn000 = new ASTlessthan(JJTLESSTHAN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) lessthan */
  try {
/*@egen*/
  "<"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void greaterthan():
{/*@bgen(jjtree) greaterthan */
  ASTgreaterthan jjtn000 = new ASTgreaterthan(JJTGREATERTHAN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) greaterthan */
  try {
/*@egen*/
  ">"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void lessequal():
{/*@bgen(jjtree) lessequal */
  ASTlessequal jjtn000 = new ASTlessequal(JJTLESSEQUAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) lessequal */
  try {
/*@egen*/
  "<="/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void greaterequal():
{/*@bgen(jjtree) greaterequal */
  ASTgreaterequal jjtn000 = new ASTgreaterequal(JJTGREATEREQUAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) greaterequal */
  try {
/*@egen*/
  ">="/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void equal():
{/*@bgen(jjtree) equal */
  ASTequal jjtn000 = new ASTequal(JJTEQUAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) equal */
  try {
/*@egen*/
  "=="/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



void arithexpr():
{/*@bgen(jjtree) arithexpr */
  ASTarithexpr jjtn000 = new ASTarithexpr(JJTARITHEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) arithexpr */
        try {
/*@egen*/
	multexpr() arithexprprime()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void arithexprprime():
{/*@bgen(jjtree) arithexprprime */
  ASTarithexprprime jjtn000 = new ASTarithexprprime(JJTARITHEXPRPRIME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) arithexprprime */
        try {
/*@egen*/
	pl() multexpr() arithexprprime()|mi() multexpr() arithexprprime()|epsilon()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void pl():
{/*@bgen(jjtree) pl */
  ASTpl jjtn000 = new ASTpl(JJTPL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) pl */
  try {
/*@egen*/
  "+"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void mi():
{/*@bgen(jjtree) mi */
  ASTmi jjtn000 = new ASTmi(JJTMI);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) mi */
  try {
/*@egen*/
  "-"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void multexpr():
{/*@bgen(jjtree) multexpr */
  ASTmultexpr jjtn000 = new ASTmultexpr(JJTMULTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) multexpr */
        try {
/*@egen*/
	simpleexpr() multexprprime()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void multexprprime():
{/*@bgen(jjtree) multexprprime */
  ASTmultexprprime jjtn000 = new ASTmultexprprime(JJTMULTEXPRPRIME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) multexprprime */
        try {
/*@egen*/
	sta() simpleexpr() multexprprime()|ob() simpleexpr() multexprprime()|epsilon()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void sta():
{/*@bgen(jjtree) sta */
  ASTsta jjtn000 = new ASTsta(JJTSTA);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) sta */
  try {
/*@egen*/
  "*"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void ob():
{/*@bgen(jjtree) ob */
  ASTob jjtn000 = new ASTob(JJTOB);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ob */
  try {
/*@egen*/
  "/"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void simpleexpr():
{/*@bgen(jjtree) simpleexpr */
  ASTsimpleexpr jjtn000 = new ASTsimpleexpr(JJTSIMPLEEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) simpleexpr */
        try {
/*@egen*/
	identity()|number()|leftb() arithexpr() rightb()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void number():
{/*@bgen(jjtree) number */
  ASTnumber jjtn000 = new ASTnumber(JJTNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) number */
  try {
/*@egen*/
  <NUM>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void epsilon():
{/*@bgen(jjtree) epsilon */
  ASTepsilon jjtn000 = new ASTepsilon(JJTEPSILON);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) epsilon */
  try {
/*@egen*//*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}